## **트랜잭션 격리 수준**

### **Read Uncommitted (커밋 전 읽기)**
트랜잭션이 존재하지 않는 상태에서는 여러 사용자가 동시에 같은 데이터를 읽고 쓸 때 문제가 발생합니다. 가장 기본적인 문제는 **Dirty Read(더티 리드)** 와 **Dirty Write(더티 라이트)** 입니다.

✅ **Dirty Read (더티 리드)**
- 하나의 트랜잭션이 아직 커밋되지 않은 데이터를 읽을 수 있는 경우.
- 예시:
    1. A 사용자가 계좌 잔고를 1000원에서 900원으로 변경했지만, 아직 커밋하지 않음.
    2. B 사용자가 A가 수정한 900원을 읽어버림.
    3. 이후 A 사용자가 롤백하면 실제 데이터는 여전히 1000원이지만, B 사용자는 900원이라고 잘못된 데이터를 사용하게 됨.

✅ **Dirty Write (더티 라이트)**
- 하나의 트랜잭션이 아직 커밋되지 않은 데이터를 덮어쓰는 경우.
- 예시:
    1. A 사용자가 상품 구매자로 **Alice**를 저장하는 트랜잭션 실행 (아직 커밋되지 않음).
    2. 동시에 B 사용자가 상품 구매자로 **Bob**을 저장하는 트랜잭션 실행 (아직 커밋되지 않음).
    3. 이후 B가 먼저 커밋되고, A도 커밋되면 최종적으로 구매자가 Alice가 되어야 하지만, Bob이 덮어쓰게 되어 데이터 불일치가 발생.

**해결 방법 → "Read Committed" (커밋 후 읽기) 격리 수준 적용**
- Dirty Read를 막기 위해, 커밋된 데이터만 읽도록 보장.
- Dirty Write를 막기 위해, 커밋되지 않은 데이터를 덮어쓰지 않도록 보장.

---

### **Read Committed (커밋 후 읽기)**
"Read Committed" 격리 수준을 적용하면 Dirty Read와 Dirty Write 문제는 해결되지만, 여전히 **비반복 읽기(Non-Repeatable Read)** 문제가 발생할 수 있습니다.

✅ **Non-Repeatable Read (비반복 읽기)**
- 같은 데이터를 두 번 읽었을 때 결과가 달라지는 문제.
- 예시:
    1. 사용자가 계좌 1과 계좌 2의 잔고 총합을 확인하려고 함.
    2. 트랜잭션이 계좌 1(1000원)을 조회한 후, 계좌 2(1500원)를 조회하기 전에, 다른 트랜잭션에서 계좌 1에서 500원을 계좌 2로 이체하고 커밋함.
    3. 사용자는 계좌 1에서 500원, 계좌 2에서 1500원을 읽어 총합을 2500원으로 잘못 인식.

✅ **Read Skew (읽기 스큐)**
- 하나의 트랜잭션에서 읽은 값들이 논리적으로 일관되지 않은 경우.
- 데이터 백업 중 일부는 변경 전 데이터를, 일부는 변경 후 데이터를 저장하면 일관성이 깨짐.

**해결 방법 → "Repeatable Read" (반복 읽기) 격리 수준 적용**
- 트랜잭션이 시작된 시점의 데이터를 기준으로 읽기를 고정(스냅숏 격리).
- 이를 통해, 한 트랜잭션 동안 같은 데이터를 여러 번 읽어도 결과가 변하지 않도록 보장.

---

### **Repeatable Read (반복 읽기)**
Repeatable Read 격리 수준을 적용하면 비반복 읽기(Non-Repeatable Read) 문제는 해결되지만, **팬텀 리드(Phantom Read)** 문제는 여전히 남아 있습니다.

✅ **Phantom Read (팬텀 리드)**
- 한 트랜잭션 내에서 같은 조건으로 데이터를 조회했을 때, 조회하는 시점마다 행의 개수가 달라지는 문제.
- 예시:
    1. 어떤 사용자가 `"잔고가 1000원 이상인 계좌"`를 조회했을 때, 결과가 5개 나옴.
    2. 그동안 다른 트랜잭션에서 새로운 계좌를 추가하고 커밋.
    3. 같은 트랜잭션 내에서 다시 `"잔고가 1000원 이상인 계좌"`를 조회하면 결과가 6개로 변함.

**해결 방법 → "Serializable" (직렬화) 격리 수준 적용**
- 모든 트랜잭션을 순차적으로 실행하는 것처럼 동작.
- 가장 강력한 격리 수준이지만, 성능 저하가 발생할 수 있음.

---

### **4. Serializable (직렬화)**

#### 해결되는 문제:
- **Dirty Read**: 다른 트랜잭션에서 커밋되지 않은 데이터를 읽을 수 없습니다.
- **Dirty Write**: 커밋되지 않은 데이터를 덮어쓰지 않습니다.
- **Non-Repeatable Read**: 트랜잭션 내에서 읽은 데이터가 변하지 않도록 보장합니다.
- **Phantom Read**: 같은 조건으로 조회할 때 결과가 달라지지 않도록 보장합니다.

#### 설명:
- **Serializable** 격리 수준은 가장 강력한 트랜잭션 격리 수준으로, **직렬화**된 트랜잭션처럼 순차적으로 실행되게 하여 모든 트랜잭션이 데이터베이스 상태를 독립적으로 변경하지 못하도록 합니다.
- 이 방식은 **Phantom Read**를 포함한 모든 문제를 해결하지만, 동시에 **성능 저하**가 발생합니다. 모든 트랜잭션이 순차적으로 처리되기 때문에 **병렬 처리**가 제한되고, 속도가 느려질 수 있습니다.

---

### **정리**
| 격리 수준 | 해결하는 문제 | 해결하지 못하는 문제 |
|-----------|------------|----------------|
| Read Uncommitted (커밋 전 읽기) | 없음 (모든 문제가 발생) | Dirty Read, Dirty Write, Non-Repeatable Read, Phantom Read |
| Read Committed (커밋 후 읽기) | Dirty Read, Dirty Write 해결 | Non-Repeatable Read, Phantom Read |
| Repeatable Read (반복 읽기) | Non-Repeatable Read 해결 | Phantom Read |
| Serializable (직렬화) | 모든 문제 해결 | 성능 저하 |

1️⃣ **아무것도 적용하지 않으면 Dirty Read, Dirty Write 발생**  
2️⃣ **Read Committed 적용 → Dirty Read, Dirty Write 방지 (하지만 Non-Repeatable Read 발생)**  
3️⃣ **Repeatable Read 적용 → Non-Repeatable Read 방지 (하지만 Phantom Read 발생)**  
4️⃣ **Serializable 적용 → 모든 문제 해결하지만 성능 저하**

이제 어떤 경우에 어떤 격리 수준을 선택해야 하는지 알 수 있겠죠? 🚀
